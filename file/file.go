package file

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/friendsofgo/errors"
	"github.com/maru44/scheman/definition"
)

type (
	File struct {
		*definition.CommonInfo
		isDefinition bool
		isMermaid    bool

		definitionFile string
		erdFile        string
	}
)

func NewFile(definitionFile, erdFile string, info *definition.CommonInfo) definition.Definition {
	return &File{
		definitionFile: definitionFile,
		erdFile:        erdFile,
		CommonInfo:     info,
		isDefinition:   true,
	}
}

func NewFileOnlyMermaid(erdFile string, info *definition.CommonInfo) definition.Definition {
	return &File{
		erdFile:    erdFile,
		CommonInfo: info,
		isMermaid:  true,
	}
}

func (f *File) EnableMermaid() {
	f.isMermaid = true
}

func (f *File) Upsert(ctx context.Context) error {
	if !f.isDefinition {
		return nil
	}
	if f.definitionFile == "" {
		return errors.New("You have to set def-file")
	}

	showAttrs := []string{"Table Name", "Column Name"}
	f.addAttr(&showAttrs, "Data Type")
	f.addAttr(&showAttrs, "PK")
	f.addAttr(&showAttrs, "Auto Generate")
	f.addAttr(&showAttrs, "Unique")
	f.addAttr(&showAttrs, "Null")
	f.addAttr(&showAttrs, "Default")
	f.addAttr(&showAttrs, "Comment")
	f.addAttr(&showAttrs, "Enum")

	ext := filepath.Ext(f.definitionFile)
	switch ext {
	case ".json":
	case ".tsv":
		return f.writeTSV(showAttrs)
	default:
		return f.writeCSV(showAttrs)
	}
	return nil
}

func (f *File) Mermaid(ctx context.Context) error {
	if !f.isMermaid {
		return nil
	}
	if f.erdFile == "" {
		return errors.New("You have to set erd-file")
	}

	file, err := os.OpenFile(f.erdFile, os.O_TRUNC|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		return errors.Wrap(err, "failed to open mermaid file")
	}

	if _, err := file.Write([]byte("```mermaid\n" + f.RawMermaid + "```\n")); err != nil {
		return errors.Wrap(err, "failed to write mermaid file")
	}
	return nil
}

func (f *File) addAttr(showAttrs *[]string, attr string) {
	if _, ok := f.IgnoreAttributes[attr]; !ok {
		*showAttrs = append(*showAttrs, attr)
	}
}

func (f *File) makeRowsSlice(shownAttrs []string) [][][]string {
	var results [][][]string
	results = append(results, [][]string{shownAttrs})
	for _, t := range f.TablesByConnection {
		table := make([][]string, len(t.Columns))
		for i, col := range t.Columns {
			rowAttr := make([]string, len(shownAttrs))
			c := definition.ConvertCol(col, t.PKey, f.DriverName)
			for ii, a := range shownAttrs {
				if a == "Table Name" {
					if i == 0 {
						rowAttr[ii] = t.Name
					} else {
						rowAttr[ii] = ""
					}
				}

				if a == "Column Name" {
					rowAttr[ii] = c.Name
				}
				if a == "Data Type" {
					rowAttr[ii] = c.DBType
				}
				if a == "PK" {
					rowAttr[ii] = fmt.Sprint(c.PK)
				}
				if a == "Auto Generate" {
					rowAttr[ii] = fmt.Sprint(c.AutoGenerated)
				}
				if a == "Unique" {
					rowAttr[ii] = fmt.Sprint(c.Unique)
				}
				if a == "Null" {
					rowAttr[ii] = fmt.Sprint(c.Nullable)
				}
				if a == "Default" {
					rowAttr[ii] = c.Default
				}
				if a == "Comment" {
					rowAttr[ii] = c.Comment
				}
				if a == "Enum" {
					rowAttr[ii] = strings.Join(c.Enum, "|")
				}
			}
			table[i] = rowAttr
		}

		results = append(results, table)
	}
	return results
}
