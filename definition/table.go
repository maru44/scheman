package definition

import (
	"regexp"
	"strings"

	"github.com/volatiletech/sqlboiler/v4/drivers"
)

type (
	Table struct {
		PageID  string
		Name    string
		Columns []Column
	}

	Column struct {
		RowID         string
		Name          string
		DBType        string
		Unique        bool
		Nullable      bool
		AutoGenerated bool
		PK            bool
		Default       string
		Comment       string
		Enum          []string
		FreeText      string
	}
)

func ConvertCol(c drivers.Column, tablePK *drivers.PrimaryKey, driverName string) Column {
	isPK := false
	if tablePK != nil {
		for _, p := range tablePK.Columns {
			if p == c.Name {
				isPK = true
				break
			}
		}
	}

	dbType := c.DBType
	def := c.Default
	var enums []string
	if driverName == "psql" {
		switch dbType {
		case "character varying":
			dbType = "varchar"
			def = strings.TrimSuffix(def, "::character varying")
		case "character":
			def = strings.TrimSuffix(def, "::bpchar")
		case "\"char\"":
			dbType = "char"
			def = strings.TrimSuffix(def, "::\"char\"")
		case "interval":
			def = strings.TrimSuffix(def, "::interval")
		case "date":
			def = strings.TrimSuffix(def, "::date")
		case "time":
			def = strings.TrimSuffix(def, "::time")
		case "timestamp with time zone":
			def = strings.TrimSuffix(def, "::timestamp with time zone")
		case "timestamp without time zone":
			def = strings.TrimSuffix(def, "::timestamp without time zone")
		case "bytea":
			def = strings.TrimSuffix(def, "::bytea")
		case "uuid":
			def = strings.TrimSuffix(def, "::uuid")
		}

		if strings.HasPrefix(dbType, "enum.") {
			r := regexp.MustCompile(`('[^']+')+`)
			enums = r.FindAllString(dbType, -1)
			dbType = "enum"
		}
	}
	if driverName == "mysql" {
		if strings.HasPrefix(dbType, "enum") {
			r := regexp.MustCompile(`('[^']+')+`)
			enums = r.FindAllString(dbType, -1)
			dbType = "enum"
		}
	}

	return Column{
		Name:          c.Name,
		DBType:        dbType,
		Unique:        c.Unique,
		Nullable:      c.Nullable,
		PK:            isPK,
		AutoGenerated: c.AutoGenerated,
		Default:       def,
		Comment:       c.Comment,
		Enum:          enums,
	}
}
